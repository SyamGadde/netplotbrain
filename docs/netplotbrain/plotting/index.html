<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>netplotbrain.plotting API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netplotbrain.plotting</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .plot_edges import _plot_edges, _npedges2dfedges
from .plot_nodes import _scale_nodes, _plot_nodes, _select_single_hemisphere_nodes
from .plot_spheres import _plot_spheres
from .plot_templates import _plot_template, _plot_template_style_filled, \
    _plot_template_style_cloudy, _plot_template_style_surface
from .plot_dimarrows import _add_axis_arrows
from .plot_parcels import _get_nodes_from_nii, _plot_parcels
from .plot_title import _add_subplot_title
from .process_input import get_frame_input
__all__ = [&#39;_plot_template&#39;, &#39;_plot_template_style_filled&#39;,
           &#39;_plot_template_style_cloudy&#39;,
           &#39;_scale_nodes&#39;, &#39;_plot_nodes&#39;, &#39;_plot_spheres&#39;,
           &#39;_plot_edges&#39;, &#39;_plot_template_style_surface&#39;,
           &#39;_add_axis_arrows&#39;, &#39;_get_nodes_from_nii&#39;, &#39;_plot_parcels&#39;,
           &#39;_select_single_hemisphere_nodes&#39;, &#39;_npedges2dfedges&#39;, &#39;_add_subplot_title&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="netplotbrain.plotting.plot_dimarrows" href="plot_dimarrows.html">netplotbrain.plotting.plot_dimarrows</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_edges" href="plot_edges.html">netplotbrain.plotting.plot_edges</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_nodes" href="plot_nodes.html">netplotbrain.plotting.plot_nodes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_parcels" href="plot_parcels.html">netplotbrain.plotting.plot_parcels</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_spheres" href="plot_spheres.html">netplotbrain.plotting.plot_spheres</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_templates" href="plot_templates.html">netplotbrain.plotting.plot_templates</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.plot_title" href="plot_title.html">netplotbrain.plotting.plot_title</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netplotbrain.plotting.process_input" href="process_input.html">netplotbrain.plotting.process_input</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="netplotbrain.plotting._add_axis_arrows"><code class="name flex">
<span>def <span class="ident">_add_axis_arrows</span></span>(<span>ax, dims=['LR', 'AP'], length=10, origin=None, azim=0, elev=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots arrows to show the 3d Axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dims</code></strong> :&ensp;<code>list, string</code></dt>
<dd>LR, AP, SI, 'all'</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int, float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>origin</code></strong> :&ensp;<code>list (len</code> of <code>3)</code></dt>
<dd>Origin of center of arrow axes.
If none, centers automatically in bottom left.</dd>
<dt><strong><code>azim</code></strong> :&ensp;<code>int</code></dt>
<dd>azim argument, for origin auto calculation</dd>
<dt><strong><code>elev</code></strong> :&ensp;<code>int</code></dt>
<dd>elev argument, for origin auto calculation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing (input axis is updated)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _add_axis_arrows(ax, dims=[&#39;LR&#39;, &#39;AP&#39;], length=10, origin=None, azim=0, elev=0):
    &#34;&#34;&#34;
    Plots arrows to show the 3d Axis.

    Parameters
    ---------------------
    ax : matplotlib ax
    dims : list, string
        LR, AP, SI, &#39;all&#39;
    length : int, float
    origin : list (len of 3)
        Origin of center of arrow axes.
        If none, centers automatically in bottom left.
    azim : int
        azim argument, for origin auto calculation
    elev : int
        elev argument, for origin auto calculation
    Returns
    -----------------
    Nothing (input axis is updated)

    &#34;&#34;&#34;
    if origin is None:
        xlim = ax.get_xlim3d()
        ylim = ax.get_ylim3d()
        zlim = ax.get_zlim3d()
        origin = [xlim[0] + 15, ylim[0] + 15, zlim[0] + 15]
        if azim &gt; 0:
            origin[1] = ylim[1] - 15
        if azim &lt;= 90 and azim &gt; -90:
            origin[0] = xlim[1] + 15
    # Check the azim to see the orientation of letters
    # S/I needs to be added.
    # Also this could probably be improved upon
    # Based on hard coding
    valign_a = &#39;center&#39;
    valign_p = &#39;center&#39;
    valign_l = &#39;center&#39;
    valign_r = &#39;center&#39;
    valign_s = &#39;bottom&#39;
    valign_i = &#39;top&#39;
    if azim &lt;= 90 and azim &gt; -90:
        halign_l = &#39;left&#39;
        halign_r = &#39;right&#39;
        if elev &gt; 45:
            valign_a = &#39;bottom&#39;
            valign_p = &#39;top&#39;
            halign_a = &#39;center&#39;
            halign_p = &#39;center&#39;
    else:
        halign_l = &#39;right&#39;
        halign_r = &#39;left&#39;
        if elev &gt; 45:
            valign_p = &#39;bottom&#39;
            valign_a = &#39;top&#39;
            halign_a = &#39;center&#39;
            halign_p = &#39;center&#39;
    if azim &gt; 0 and elev &lt;= 45:
        halign_a = &#39;left&#39;
        halign_p = &#39;right&#39;
    else:
        halign_a = &#39;right&#39;
        halign_p = &#39;left&#39;
    # Check if input is all
    if dims == &#39;all&#39;:
        dims = [&#39;LR&#39;, &#39;AP&#39;, &#39;SI&#39;]
    # Check if input is string, make list
    if isinstance(dims, str):
        dims = [dims]
    # Make null lists
    arrows_dx = []
    arrows_dy = []
    arrows_dz = []
    # Half the arrow size
    l = length/2
    # Go through each dimension and derive arrow coordinates
    # For each dim, two arrows are plotted going from origin in both directions
    if &#39;LR&#39; in dims:
        arrows_dx += [-l, l]
        arrows_dy += [0, 0]
        arrows_dz += [0, 0]
        ax.text(origin[0] - l, origin[1], origin[2], &#39;L&#39;, fontsize=&#39;xx-small&#39;,
                color=&#39;gray&#39;, horizontalalignment=halign_l, verticalalignment=valign_l)
        ax.text(origin[0] + l, origin[1], origin[2], &#39;R&#39;, fontsize=&#39;xx-small&#39;,
                color=&#39;gray&#39;, horizontalalignment=halign_r, verticalalignment=valign_r)
    if &#39;AP&#39; in dims:
        arrows_dx += [0, 0]
        arrows_dy += [-l, l]
        arrows_dz += [0, 0]
        ax.text(origin[0], origin[1] - l, origin[2], &#39;P&#39;, fontsize=&#39;xx-small&#39;,
                color=&#39;gray&#39;, horizontalalignment=halign_a, verticalalignment=valign_a)
        ax.text(origin[0], origin[1] + l, origin[2], &#39;A&#39;, fontsize=&#39;xx-small&#39;,
                color=&#39;gray&#39;, horizontalalignment=halign_p, verticalalignment=valign_p)
    if &#39;SI&#39; in dims:
        arrows_dx += [0, 0]
        arrows_dy += [0, 0]
        arrows_dz += [-l, l]
        ax.text(origin[0], origin[1], origin[2] - l, &#39;I&#39;,
                fontsize=&#39;xx-small&#39;, color=&#39;gray&#39;, verticalalignment=valign_i)
        ax.text(origin[0], origin[1], origin[2] + l, &#39;S&#39;,
                fontsize=&#39;xx-small&#39;, color=&#39;gray&#39;, verticalalignment=valign_s)
    # Arrow origins
    arrows_x = [origin[0]] * (len(dims) * 2)
    arrows_y = [origin[1]] * (len(dims) * 2)
    arrows_z = [origin[2]] * (len(dims) * 2)
    # Plot arrows with quiver function
    ax.quiver(arrows_x, arrows_y, arrows_z, arrows_dx, arrows_dy,
              arrows_dz, color=&#39;gray&#39;, linewidth=0.5, arrow_length_ratio=0.5)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._add_subplot_title"><code class="name flex">
<span>def <span class="ident">_add_subplot_title</span></span>(<span>ax, azim, elev, title='auto', hemisphere='both', titlefont='Sawasdee', titlefontsize='medium', titleloc='center', titleweight='regular', titlecolor='gray')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _add_subplot_title(ax, azim, elev, title=&#39;auto&#39;, hemisphere=&#39;both&#39;, titlefont=&#39;Sawasdee&#39;, titlefontsize=&#39;medium&#39;, titleloc=&#39;center&#39;, titleweight=&#39;regular&#39;, titlecolor=&#39;gray&#39;):

    if title == &#39;auto&#39;:
        viewcoord = (azim, elev)
        title = &#39;&#39;
        if viewcoord == (180, 10): 
            title = &#39;View: Left&#39;
        elif viewcoord == (0, 10): 
            title = &#39;View: Right&#39;
        elif viewcoord == (90, 10): 
            title = &#39;View: Anterior&#39;
        elif viewcoord == (-90, 10): 
            title = &#39;View: Posterior&#39;
        elif viewcoord == (-90, 90): 
            title = &#39;View: Superior&#39;     
        elif viewcoord == (90, 90): 
            title = &#39;View: Inferior&#39;
        # Add hemisphere
        if hemisphere == &#39;L&#39; or hemisphere == &#39;left&#39;: 
            title += &#39; (left hemisphere)&#39;
        elif hemisphere == &#39;R&#39; or hemisphere == &#39;right&#39;: 
            title += &#39; (right hemisphere)&#39; 

    ax.set_title(title, fontname=titlefont,
                     fontweight=titleweight, color=titlecolor,
                     fontsize=titlefontsize,
                     loc=titleloc)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._get_nodes_from_nii"><code class="name flex">
<span>def <span class="ident">_get_nodes_from_nii</span></span>(<span>img, nodes=None, voxsize=None, template=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns xyz coordinates from node input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>str, nibabel image</code> or <code>dict</code></dt>
<dd>If string, link to the image.
If img, a nifti where each roi is its own number.
If dict, templateflow dictionary to one single nifti image</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>Node dataframe.</dd>
<dt><strong><code>voxsize</code></strong> :&ensp;<code>int</code></dt>
<dd>if not, None, the size of voxels in cord system.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe with x,y,z cordinates</code> of <code>nodes</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>img : loaded nifti image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _get_nodes_from_nii(img, nodes=None, voxsize=None, template=None):
    &#34;&#34;&#34;
    Returns xyz coordinates from node input.

    Parameters
    ------------------------
    img : str, nibabel image or dict
        If string, link to the image.
        If img, a nifti where each roi is its own number.
        If dict, templateflow dictionary to one single nifti image
    nodes : dataframe
        Node dataframe.
    voxsize : int
        if not, None, the size of voxels in cord system.

    Returns
    -----------------------
    nodes : dataframe with x,y,z cordinates of nodes
    img : loaded nifti image.
    &#34;&#34;&#34;
    # Get templateflow image, if dict
    if isinstance(img, dict):
        # Add template to dict
        if template is not None and &#39;template&#39; not in img:
            img[&#39;template&#39;] = template
        # If extension not included in img, add it.
        # Could be some instances where this is not wanted
        if &#39;extension&#39; not in img:
            img[&#39;extension&#39;] = &#39;.nii.gz&#39;
        imgpath = tf.get(**img)
        img = nib.load(imgpath)
    # load image, if string
    if isinstance(img, str):
        img = img.load(str)

    # Resize img to desired output resolution
    # Will be same as template
    if voxsize is not None:
        img = resample_to_output(img, [voxsize] * 3, mode=&#39;nearest&#39;)

    # Get each roi
    imgdata = img.get_fdata(caching=&#39;unchanged&#39;)
    rois = np.unique(imgdata)
    # remove 0 roi (i.e. background)
    rois = rois[rois != 0]
    x_coord = []
    y_coord = []
    z_coord = []
    for r in rois:
        allcoords = np.where(imgdata == r)
        x_coord.append(np.median(allcoords[0]))
        y_coord.append(np.median(allcoords[1]))
        z_coord.append(np.median(allcoords[2]))

    # If nodes is None, define the dataframe
    if nodes is None:
        nodes = pd.DataFrame()

    # Add the median coordinates into dataframe
    # Origin is at 0,0,0, but scale affine diag for voxel spacing.
    # Scaling affine should be checked in future as general solution
    nodes[&#39;x&#39;] = x_coord
    nodes[&#39;y&#39;] = y_coord
    nodes[&#39;z&#39;] = z_coord

    return nodes, img</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._npedges2dfedges"><code class="name flex">
<span>def <span class="ident">_npedges2dfedges</span></span>(<span>edges, edgethreshold=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A function which transforms numpy array edges into dataframe to be compatible
with all functionality.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edges</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>n x n array of edges</dd>
<dt><strong><code>edgethreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>only find edges over a certain threshold</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _npedges2dfedges(edges, edgethreshold=0):
    &#34;&#34;&#34;
    A function which transforms numpy array edges into dataframe to be compatible
    with all functionality.

    Parameters
    ---------------------
    edges : numpy array
        n x n array of edges
    edgethreshold : float
        only find edges over a certain threshold
    &#34;&#34;&#34;
    ind = np.where(edges &gt; edgethreshold)
    weights = edges[ind]
    # Create dataframe
    df = pd.DataFrame(data={&#39;i&#39;: ind[0], &#39;j&#39;: ind[1], &#39;weight&#39;: weights})
    return df</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_edges"><code class="name flex">
<span>def <span class="ident">_plot_edges</span></span>(<span>ax, nodes, edges, edgewidth=None, edgewidthscale=1, edgecolor='k', edgecol=['i', 'j'], edgealpha=None, highlightnodes=None, highlightlevel=None, edgehighlightbehaviour='both')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the edges on the plot</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>node dataframe with x, y, z coordinates (at least).</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>array</code> or <code>dataframe</code></dt>
<dd>numpy array (adj matrix) or edgelist (df.columns = ['i', 'j', &hellip;])</dd>
<dt><strong><code>edgewidth</code></strong> :&ensp;<code>string</code></dt>
<dd>Column pointing to edges.</dd>
<dt><strong><code>edgewidthscale</code></strong> :&ensp;<code>float, int</code></dt>
<dd>For display purposes, scale edges by value.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>matplotlib color</code></dt>
<dd>Colour of edges</dd>
<dt><strong><code>edgecol</code></strong> :&ensp;<code>list (2 elements). Default: ['i', 'j']</code></dt>
<dd>list of length 2.
The first two, reference the node indicies in nodes.
The third referencees the weights.</dd>
<dt><strong><code>edgealpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Transparency of edges.</dd>
<dt><strong><code>highlightnodes</code></strong> :&ensp;<code>list</code></dt>
<dd>See netplotbrain.plot</dd>
<dt><strong><code>highlightlevel</code></strong> :&ensp;<code>float </code></dt>
<dd>See netplotbrain.plot</dd>
<dt><strong><code>edgehighlightbehaviour</code></strong> :&ensp;<code>str</code></dt>
<dd>alternatives "both" or "any" or None.
Governs edge dimming when highlightnodes is on
If both, then highlights only edges between highlighted nodes.
If any, then only edges connecting any of the nodes are highlighted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_edges(ax, nodes, edges, edgewidth=None, edgewidthscale=1, edgecolor=&#39;k&#39;, edgecol=[&#39;i&#39;, &#39;j&#39;], edgealpha=None, highlightnodes=None, highlightlevel=None, edgehighlightbehaviour=&#39;both&#39;):
    &#34;&#34;&#34;
    Plots the edges on the plot

    Parameters
    ----------------------------
    ax : matplotlib ax
    nodes : dataframe
        node dataframe with x, y, z coordinates (at least).
    edges : array or dataframe
        numpy array (adj matrix) or edgelist (df.columns = [&#39;i&#39;, &#39;j&#39;, ...])
    edgewidth : string
        Column pointing to edges.
    edgewidthscale : float, int
        For display purposes, scale edges by value.
    edgecolor : matplotlib color
        Colour of edges
    edgecol : list (2 elements). Default: [&#39;i&#39;, &#39;j&#39;]
        list of length 2.
        The first two, reference the node indicies in nodes.
        The third referencees the weights.
    edgealpha : float
        Transparency of edges.
    highlightnodes : list
        See netplotbrain.plot
    highlightlevel : float 
        See netplotbrain.plot
    edgehighlightbehaviour : str
        alternatives &#34;both&#34; or &#34;any&#34; or None.
        Governs edge dimming when highlightnodes is on
        If both, then highlights only edges between highlighted nodes.
        If any, then only edges connecting any of the nodes are highlighted.



    Returns
    ----------------------
    Nothing
    &#34;&#34;&#34;
    # Convert highlightnodes binary list to index list
    hl_idx = np.where(np.array(highlightnodes)==1)[0]
    # if dataframe
    for _, row in edges.iterrows():
        # if row[edgecol[0]] != 0 and row[edgecol[1]] != 0:
        if edgewidth is None:
            ew = edgewidthscale
        else:
            ew = row[edgewidth] * edgewidthscale
        if row[edgecol[0]] in nodes.index and row[edgecol[1]] in nodes.index:
            ea = _get_edge_highlight_alpha(
                row[edgecol[0]], row[edgecol[1]], hl_idx, highlightlevel, edgehighlightbehaviour, edgealpha)
            xp = nodes.loc[list((row[edgecol[0]], row[edgecol[1]]))][&#39;x&#39;]
            yp = nodes.loc[list((row[edgecol[0]], row[edgecol[1]]))][&#39;y&#39;]
            zp = nodes.loc[list((row[edgecol[0]], row[edgecol[1]]))][&#39;z&#39;]
            ax.plot(xp, yp, zp, color=edgecolor, linewidth=ew, alpha=ea)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_nodes"><code class="name flex">
<span>def <span class="ident">_plot_nodes</span></span>(<span>ax, nodes, nodecolor='salmon', nodesize=20, nodecols=['x', 'y', 'z'])</span>
</code></dt>
<dd>
<div class="desc"><p>Function that plots nodes in figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>node dataframe with x, y, z coordinates, must include nodecols.</dd>
<dt><strong><code>nodesize</code></strong> :&ensp;<code>string</code> or <code>float, int</code></dt>
<dd>if string, must refer to a column in nodes.</dd>
<dt><strong><code>nodecolor</code></strong> :&ensp;<code>string</code> or <code>matplotlib color</code></dt>
<dd>if non-color string, must refer to a column in nodes</dd>
<dt><strong><code>nodecols</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>name of node column coordinates in datadrame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_nodes(ax, nodes, nodecolor=&#39;salmon&#39;, nodesize=20, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]):
    &#34;&#34;&#34;
    Function that plots nodes in figure

    Parameters
    ---------------
    ax : matplotlib ax
    nodes : dataframe
        node dataframe with x, y, z coordinates, must include nodecols.
    nodesize : string or float, int
        if string, must refer to a column in nodes.
    nodecolor : string or matplotlib color
        if non-color string, must refer to a column in nodes
    nodecols : list of string
        name of node column coordinates in datadrame


    Returns
    -------------
    Nothing

    &#34;&#34;&#34;
    # Check if nodesize input is column in node data
    if isinstance(nodesize, str) and nodesize in nodes.columns:
        ns = nodes[nodesize]
    else:
        ns = nodesize
    # Set colormap
    nc = nodecolor
    ax.scatter(nodes[nodecols[0]], nodes[nodecols[1]],
               nodes[nodecols[2]], s=ns, color=nc)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_parcels"><code class="name flex">
<span>def <span class="ident">_plot_parcels</span></span>(<span>ax, img, alpha, cmap='Set2', parcel_surface_resolution=1, hemisphere='both')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_parcels(ax, img, alpha, cmap=&#39;Set2&#39;, parcel_surface_resolution=1, hemisphere=&#39;both&#39;):
    # Due to only being able to get data once, this leads to problems when LR hemi are specieid
    data = img.get_fdata(caching=&#39;unchanged&#39;).copy()
    # If single hemisphere, get only that side
    data = _select_single_hemisphere_template(data, hemisphere)  
    # Get the number of nodes (subtract 1 for 0)
    nodelabels = np.unique(data)
    if 0 in nodelabels:
        nodelabels = nodelabels[1:]
    # Create a nnode length (or longer) array which repeats colormap
    if isinstance(cmap, str):
        colors = _colorarray_from_string(cmap, len(nodelabels))
    else:
        # If colors has already been defined prior to calling this function
        colors = cmap
    # loop through each node and plot verticies as different color
    # Possible improvement: could be made without for loop
    # And vals is used to plot color
    for ni, r in enumerate(nodelabels):
        dtmp = np.zeros(data.shape)
        dtmp[data == r] = 1
        verts, faces, _, _ = measure.marching_cubes(
            dtmp, step_size=parcel_surface_resolution)
        vertices = verts[faces]
        # for n in np.unique(vals):
        mesh = Poly3DCollection(vertices)
        mesh.set_facecolor(colors[ni])
        if isinstance(colors, str): 
            mesh.set_alpha(alpha)
        elif colors.shape[1] != 4: 
            mesh.set_alpha(alpha)
        ax.add_collection3d(mesh)

    ax.set_xlim(0, data.shape[0])
    ax.set_ylim(0, data.shape[1])
    ax.set_zlim(0, data.shape[2])</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_spheres"><code class="name flex">
<span>def <span class="ident">_plot_spheres</span></span>(<span>ax, nodes, nodecolor='salmon', nodesize=20, nodescale=1, nodecols=['x', 'y', 'z'], alpha=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that plots spheres in figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>node dataframe with x, y, z coordinates.</dd>
<dt><strong><code>nodesize</code></strong> :&ensp;<code>string</code> or <code>float, int</code></dt>
<dd>if string, must refer to a column in nodes.</dd>
<dt><strong><code>nodescale</code></strong> :&ensp;<code>int</code></dt>
<dd>factor to scale all nodes by</dd>
<dt><strong><code>nodecolor</code></strong> :&ensp;<code>string</code> or <code>matplotlib color</code></dt>
<dd>if non-color string, must refer to a column in nodes</dd>
<dt><strong><code>nodecols</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>name of node column coordinates in datadrame</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_spheres(ax, nodes, nodecolor=&#39;salmon&#39;, nodesize=20, nodescale=1, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], alpha=None):
    &#34;&#34;&#34;
    Function that plots spheres in figure

    Parameters
    ---------------
    ax : matplotlib ax
    nodes : dataframe
        node dataframe with x, y, z coordinates.
    nodesize : string or float, int
        if string, must refer to a column in nodes.
    nodescale : int
        factor to scale all nodes by
    nodecolor : string or matplotlib color
        if non-color string, must refer to a column in nodes
    nodecols : list of string
        name of node column coordinates in datadrame

    Returns
    -------------
    Nothing

    &#34;&#34;&#34;
    
    # Loop through each node and plot a surface plot
    for index, row in nodes.iterrows():
        # Get the xyz coords for the node
        c = [row[nodecols[0]],
             row[nodecols[1]],
             row[nodecols[2]]]

        # Check if nodesize is in the dataframe
        if nodesize in nodes.keys():
            r = row[nodesize] * nodescale
        else:
            r = nodesize * nodescale

        u, v = np.mgrid[0:2*np.pi:50j, 0:np.pi:50j]

        # Calculate the x,y,z coordinates of each sphere
        x = r*np.cos(u)*np.sin(v)
        y = r*np.sin(u)*np.sin(v)
        z = r*np.cos(v)
        
        # Select the node color if string or array
        if isinstance(nodecolor, np.ndarray):
            ncolor = nodecolor[index]
        else:
            ncolor = nodecolor
            
        ax.plot_surface(c[0]+x, c[1]+y, c[2]+z,
                        color=ncolor,
                        alpha=alpha)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_template"><code class="name flex">
<span>def <span class="ident">_plot_template</span></span>(<span>ax, style='filled', template='MNI152NLin2009cAsym', templatecolor='lightgray', alpha=0.2, voxsize=None, azim=0, elev=0, surface_detection=None, surface_resolution=2, edgethreshold=0.8, hemisphere='both')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_template(ax, style=&#39;filled&#39;, template=&#39;MNI152NLin2009cAsym&#39;, templatecolor=&#39;lightgray&#39;, alpha=0.2, voxsize=None, azim=0, elev=0, surface_detection=None, surface_resolution=2, edgethreshold=0.8, hemisphere=&#39;both&#39;):
    if isinstance(template, str):
        if not os.path.exists(template):
            if surface_detection is None and style == &#39;surface&#39;:
                surface_detection = _get_surface_level_for_template(template)
            tf_kwargs = {}
            # Add kwargs to specify specific templates
            if &#39;MNI152&#39; in template or &#39;OASIS&#39; in template:
                tf_kwargs = {
                    &#39;suffix&#39;: &#39;T1w&#39;,
                    &#39;resolution&#39;: 1,
                }
            if &#39;WHS&#39; in template:
                tf_kwargs = {
                    &#39;resolution&#39;: 1,
                }
            template = tf.get(template=template, desc=&#39;brain&#39;,
                              extension=&#39;.nii.gz&#39;, **tf_kwargs)
            # If multiple templates still remain, take the first
            # This may lead to suboptimal performence for some templates
            if isinstance(template, list):
                template = template[0]
        img = nib.load(template)
    elif isinstance(template, (nib.Nifti1Image, nib.Nifti2Image)):
        img = template
    if voxsize is not None:
        img = resample_to_output(img, [voxsize] * 3)
    data = img.get_fdata()
    data = _select_single_hemisphere_template(data, hemisphere)
    if style == &#39;filled&#39;:
        _plot_template_style_filled(ax, data, alpha, templatecolor)
    elif style == &#39;cloudy&#39;:
        _plot_template_style_cloudy(ax, data, azim, elev, edgethreshold, templatecolor, alpha)
    elif style == &#39;surface&#39;:
        _plot_template_style_surface(
            ax, data, alpha, template, templatecolor, surface_resolution, surface_detection)
    return img.affine</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_template_style_cloudy"><code class="name flex">
<span>def <span class="ident">_plot_template_style_cloudy</span></span>(<span>ax, data, azim, elev, edgethreshold, templatecolor, alpha=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_template_style_cloudy(ax, data, azim, elev, edgethreshold, templatecolor, alpha=1):
    # If the viewpoint is not at 0,0, rotate the image so the edge thresholding occurs at approriate angle
    if azim != 0:
        data = rotate(data, -azim, axes=[0, 1], reshape=False)
    if elev != 0:
        data = rotate(data, -elev, axes=[0, 2], reshape=False)
    # Apply sobel filter to ax1 and ax2 (viewpoint will be relative to rorated ax0)
    sdata_ax1, sdata_ax2 = [sobel(data, axis=n) for n in range(1, 3)]
    # Interpolation
    # sdata_ax1 = interpolation.spline_filter(sdata_ax1)
    # sdata_ax2 = interpolation.spline_filter(sdata_ax2)
    # Combine edge thresholding
    sdata = np.hypot(sdata_ax1, sdata_ax2)
    sdata = spline_filter1d(sdata, axis=0)
    # Rotate back
    if elev != 0:
        sdata = rotate(sdata, elev, axes=[0, 2], reshape=False)
    if azim != 0:
        sdata = rotate(sdata, azim, axes=[0, 1], reshape=False)
    # Binarize sobel filter in relation to threshold
    bdata = np.abs(sdata) &gt; np.max(np.abs(sdata)) * edgethreshold
    # Plot resulting edges as a scatter
    x, y, z = np.where(bdata == 1)
    # ax.voxels(bdata, alpha=0.2, edgecolor=None, facecolor=&#39;lightgray&#39;)
    ax.scatter(x, y, z, s=5, facecolor=templatecolor,
               edgecolors=None, marker=&#39;s&#39;, alpha=alpha)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_template_style_filled"><code class="name flex">
<span>def <span class="ident">_plot_template_style_filled</span></span>(<span>ax, data, alpha, templatecolor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_template_style_filled(ax, data, alpha, templatecolor):
    ax.voxels(data, alpha=alpha, zorder=-100,
              facecolor=templatecolor, edgecolor=None, shade=False)</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._plot_template_style_surface"><code class="name flex">
<span>def <span class="ident">_plot_template_style_surface</span></span>(<span>ax, data, alpha, template, templatecolor='gray', surface_resolution=2, surface_detection=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the function skimage.measure.marching_cubes to identify a surface.</p>
<p>surface_resolution : int
The resolution of the surface (see argument step_size in marching_cubes)
surface_detection : float
The value used to detect the surface boundrary (see argument level in marching_cubes).
Some default choices are made for various templates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot_template_style_surface(ax, data, alpha, template, templatecolor=&#39;gray&#39;, surface_resolution=2, surface_detection=None):
    &#34;&#34;&#34;
    Uses the function skimage.measure.marching_cubes to identify a surface.

    surface_resolution : int
        The resolution of the surface (see argument step_size in marching_cubes)
    surface_detection : float
        The value used to detect the surface boundrary (see argument level in marching_cubes).
        Some default choices are made for various templates
    &#34;&#34;&#34;
    verts, faces, _, _ = measure.marching_cubes(
        data, level=surface_detection, step_size=surface_resolution)
    mesh = Poly3DCollection(verts[faces])
    mesh.set_facecolor(templatecolor)
    mesh.set_alpha(alpha)
    ax.add_collection3d(mesh)
    ax.set_xlim(0, data.shape[0])
    ax.set_ylim(0, data.shape[1])
    ax.set_zlim(0, data.shape[2])</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._scale_nodes"><code class="name flex">
<span>def <span class="ident">_scale_nodes</span></span>(<span>nodes, affine=None, nodecols=['x', 'y', 'z'])</span>
</code></dt>
<dd>
<div class="desc"><p>Scales nodes from MNI coordinates to ax with origin of 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>node dataframe with x, y, z coordinates.</dd>
<dt><strong><code>affine</code></strong> :&ensp;<code>array</code></dt>
<dd>3x4 array from img.affine (nibabel image).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe</code></dt>
<dd>node dataframe with recaled x, y, z coordinates to account for affine matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _scale_nodes(nodes, affine=None, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]):
    &#34;&#34;&#34;
    Scales nodes from MNI coordinates to ax with origin of 0.

    Parameters
    ---------------
    nodes : dataframe
        node dataframe with x, y, z coordinates.
    affine : array
        3x4 array from img.affine (nibabel image).

    Returns
    ----------------
    nodes : dataframe
        node dataframe with recaled x, y, z coordinates to account for affine matrix.

    &#34;&#34;&#34;
    nodes_scaled = nodes.copy()
    if affine is not None:
        nodes_scaled[nodecols[0]] = (nodes_scaled[nodecols[0]] - affine[0, -1]) / affine[0, 0]
        nodes_scaled[nodecols[1]] = (nodes_scaled[nodecols[1]] - affine[1, -1]) / affine[1, 1]
        nodes_scaled[nodecols[2]] = (nodes_scaled[nodecols[2]] - affine[2, -1]) / affine[2, 2]
    return nodes_scaled</code></pre>
</details>
</dd>
<dt id="netplotbrain.plotting._select_single_hemisphere_nodes"><code class="name flex">
<span>def <span class="ident">_select_single_hemisphere_nodes</span></span>(<span>nodes, affine, hemisphere, nodecols=['x', 'y', 'z'])</span>
</code></dt>
<dd>
<div class="desc"><p>Only take nodes from datafrom that match requested hemisphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _select_single_hemisphere_nodes(nodes, affine, hemisphere, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]):
    &#34;&#34;&#34;
    Only take nodes from datafrom that match requested hemisphere 
    &#34;&#34;&#34;
    if hemisphere == &#39;left&#39; or hemisphere == &#39;L&#39;:
        sel = nodes[nodecols[0]] * affine[0, 0] &lt; np.abs(affine[0, -1])
        nodes = nodes[sel]
    elif hemisphere == &#39;right&#39; or hemisphere == &#39;R&#39;:
        sel = nodes[nodecols[0]] * affine[0, 0] &gt; np.abs(affine[0, -1])
        nodes = nodes[sel]
    return nodes</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netplotbrain" href="../index.html">netplotbrain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="netplotbrain.plotting.plot_dimarrows" href="plot_dimarrows.html">netplotbrain.plotting.plot_dimarrows</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_edges" href="plot_edges.html">netplotbrain.plotting.plot_edges</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_nodes" href="plot_nodes.html">netplotbrain.plotting.plot_nodes</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_parcels" href="plot_parcels.html">netplotbrain.plotting.plot_parcels</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_spheres" href="plot_spheres.html">netplotbrain.plotting.plot_spheres</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_templates" href="plot_templates.html">netplotbrain.plotting.plot_templates</a></code></li>
<li><code><a title="netplotbrain.plotting.plot_title" href="plot_title.html">netplotbrain.plotting.plot_title</a></code></li>
<li><code><a title="netplotbrain.plotting.process_input" href="process_input.html">netplotbrain.plotting.process_input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="netplotbrain.plotting._add_axis_arrows" href="#netplotbrain.plotting._add_axis_arrows">_add_axis_arrows</a></code></li>
<li><code><a title="netplotbrain.plotting._add_subplot_title" href="#netplotbrain.plotting._add_subplot_title">_add_subplot_title</a></code></li>
<li><code><a title="netplotbrain.plotting._get_nodes_from_nii" href="#netplotbrain.plotting._get_nodes_from_nii">_get_nodes_from_nii</a></code></li>
<li><code><a title="netplotbrain.plotting._npedges2dfedges" href="#netplotbrain.plotting._npedges2dfedges">_npedges2dfedges</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_edges" href="#netplotbrain.plotting._plot_edges">_plot_edges</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_nodes" href="#netplotbrain.plotting._plot_nodes">_plot_nodes</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_parcels" href="#netplotbrain.plotting._plot_parcels">_plot_parcels</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_spheres" href="#netplotbrain.plotting._plot_spheres">_plot_spheres</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_template" href="#netplotbrain.plotting._plot_template">_plot_template</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_template_style_cloudy" href="#netplotbrain.plotting._plot_template_style_cloudy">_plot_template_style_cloudy</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_template_style_filled" href="#netplotbrain.plotting._plot_template_style_filled">_plot_template_style_filled</a></code></li>
<li><code><a title="netplotbrain.plotting._plot_template_style_surface" href="#netplotbrain.plotting._plot_template_style_surface">_plot_template_style_surface</a></code></li>
<li><code><a title="netplotbrain.plotting._scale_nodes" href="#netplotbrain.plotting._scale_nodes">_scale_nodes</a></code></li>
<li><code><a title="netplotbrain.plotting._select_single_hemisphere_nodes" href="#netplotbrain.plotting._select_single_hemisphere_nodes">_select_single_hemisphere_nodes</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>