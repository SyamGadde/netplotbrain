<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>netplotbrain.plot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netplotbrain.plot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np
import inspect
import pandas as pd
from .plotting import _plot_template, _plot_template_style_filled, _plot_template_style_cloudy,\
    _plot_edges, _plot_nodes, _plot_spheres,\
    _scale_nodes, _add_axis_arrows, _plot_template_style_surface, _get_nodes_from_nii, _plot_parcels,\
    _select_single_hemisphere_nodes, _npedges2dfedges, _add_subplot_title, get_frame_input
    
from .utils import _highlight_nodes, _get_colorby_colors, _set_axes_equal, _set_axes_radius, _get_view


def plot(nodes=None, fig=None, ax=None, view=&#39;L&#39;, frames=1, edges=None, template=None, templatestyle=&#39;filled&#39;, templatealpha=0.2,
         templatevoxsize=None, templatecolor=&#39;lightgray&#39;, surface_resolution=2, templateedgethreshold=0.7, arrowaxis=&#39;auto&#39;, arrowlength=10,
         arroworigin=None, edgecolor=&#39;k&#39;, nodesize=1, nodescale=5, nodecolor=&#39;salmon&#39;, nodetype=&#39;spheres&#39;, nodecolorby=None,
         nodecmap=&#39;Dark2&#39;, edgescale=1, edgeweights=True, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], nodeimg=None, nodealpha=1, hemisphere=&#39;both&#39;, title=&#39;auto&#39;, highlightnodes=None,
         edgealpha=1, highlightlevel=0.85, edgehighlightbehaviour=&#39;both&#39;):
    # sourcery skip: merge-nested-ifs
    &#34;&#34;&#34;
    Plot a network on a brain

    Parameters
    ---------------------

    ax : matplotlib ax with 3D projection
        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        bnv.plot(ax, ...)
    view : string, list, or tuple
        if string: alternatives are &#39;A&#39; (anterior), &#39;P&#39; (posteiror), &#39;L&#39; (left), &#39;R&#39; (right), &#39;I&#39; (inferior), &#39;S&#39; (superior)
        or any combination of these (e.g &#39;LR&#39;, &#39;AP&#39;)
        The string can contain multiple combinations (e.g. LSR)
        if list: multiple strings (as above) which will create new rows of subplots.
        if tuple: (azim, elev) where azim rotates along xy, and elev rotates along xz.
        If LR or AP view combinations only, you can specify i.e. &#39;AP-&#39; to rotate in the oposite direction
    nodes : dataframe, string
        The dataframe must include x, y, z columns that correspond to coordinates of nodes (see nodecols to change this).
        Can include additional infomation for node size and color.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column. 
    edges : dataframe, numpy array, or string
        If dataframe, must include i, j columns (and weight, for weighted).
        i and j specify indicies in nodes.
        See edgecols if you want to change the default column names. 
        if numpy array, square adjacecny array.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column. 
    template : str or nibabel nifti
        Path to nifti image, or templateflow template name (see templateflow.org) in order to automatically download T1 template.
    templatestyle : str
        can be &#39;surface&#39;: (a surface is rendered from the template),
               &#39;filled&#39;: (a single transparant color)
               &#39;cloudy&#39;: cloudy (cloudy scatter edges outline the figure)
    surface_resolution : int
        If templatestyle==&#39;surface&#39; controls the size of the triangles used in the surface reconstruction (default: 2).
    templatecolor : str
        If templatestyle==&#39;surface&#39; or &#39;filled&#39;, the color of template voxels
    templateedgedetection : float
        If templatestyle==&#39;cloudy&#39;, can tweak the edges detection threshold.
    templatealpha : float
        Opacity of template voxels.
    templatevoxelsize : int
        Resize voxels this size. Larger voxels = quicker. Default = 2
    arrowaxis : list or str
        Adds axis arrows onto plot. Alternatives are: LR, AP, SI, &#39;all&#39;
    arrowlength : int, float
        Length of arrow
    arroworigin : list
        x,y,z coordinates of arrowaxis. Note 0,0,0 is bottom left.
    edgecolor : matplotlib coloring
        Can be string (default &#39;black&#39;) or list of 3D/4D colors for each edge.
    edgewidth : int, float
        Specify width of edges. If auto, will plot the value in edge array (if array) or the weight column (if in pandas dataframe), otherwise 2.
    edgeweights : string
        String that specifies column in edge dataframe that contains weights.
        If numpy array is edge input, can be True (default) to specify edge weights.
    edgealpha : float
        Transparency of edges.
    nodesize : str, int, float
        If string, can plot a column
    nodecolorby : str
        Column in dataframe that should get different colors (cannot be set with nodecolor)
    nodecmap : str
        Matplotlib colormap for node coloring with nodecolorby. 
    nodecolor : matplotlib coloring
        Can be string (default &#39;black&#39;) or list of 3D/4D colors for each edge.
    nodetype : str
        Can be &#39;spheres&#39;, &#39;circles&#39;, or (if nodeimg is specified) &#39;parcels&#39;.
    nodeimg : str or nii
        String to filename or nibabel object that contains nodes as int.
    nodealpha : float
        Specify the transparency of the nodes
    frames : int
        If specifying 2 views (e.g. LR or AP) and would like to rotates a between them.
        This value will indicate the number of rotations to get from L to R.
        For any other view specification, (e.g. specifying string such as &#39;LSR&#39;)
        then this value is not needed.
    hemisphere: string or list
        If string, can be left or right to specify single hemisphere to include.
        If list, should match the size of views and contain strings to specify hemisphere.
        Can be abbreviated to L, R and (empty string possible if both hemisphere plotted).  
        Between hemispehre edges are deleted.
    nodecols : list
        Node column names in node dataframe. Default is x, y, z (specifying coordinates)
    edgecols : list
        Edge columns names in edge dataframe. Default is i and j (specifying nodes).
    highlightnodes : int, list, dict
        List or int point out which nodes you want to be highlighted.
        If dict, should be a single column-value pair.
        Example: highlight all nodes of that, in the node dataframe, have a community
        value of 1, the input will be {&#39;community&#39;: 1}.   
    highlightlevel : float
        Intensity of the highlighting (opposite of alpha).
        Value between 0 and 1, if 1, non-highlighted nodes are fully transparent.
        If 0, non-highlighted nodes are same alpha level as highlighted nodes.
        Default 0.85. 
    edgehighlightbehaviour : str
        Alternatives &#34;both&#34; or &#34;any&#34; or None.
        Governs edge dimming when highlightnodes is on
        If both, then highlights only edges between highlighted nodes.
        If any, then only edges connecting any of the nodes are highlighted.


    &#34;&#34;&#34;
    # Load edge and nodes if string is provided. 
    if isinstance(nodes, str): 
        nodes = pd.read_csv(nodes, sep=&#39;\t&#39;, index_col=0)
    if isinstance(edges, str): 
        edges = pd.read_csv(edges, sep=&#39;\t&#39;, index_col=0)
    # get the number of views
    if isinstance(view, list):
        nrows = len(view)
    else:
        nrows = 1
        view = [view]
    # If specific views are given, calculate value of frames.
    if len(view[0]) &gt; 2:
        frames = len(view[0])
    n_subplots = nrows * frames
    if ax is not None and not isinstance(ax, list) and n_subplots &gt; 1:
        raise ValueError(
            &#39;Ax input must be a list when requesting multiple frames&#39;)
    if isinstance(ax, list):
        if len(ax) != n_subplots:
            raise ValueError(&#39;Ax list, must equal number of frames requested&#39;)
    # Init figure, if not given as input
    if ax is None:
        fig = plt.figure(figsize=(frames * 3, 3 * nrows))
        colnum = frames * 10
        rows = nrows * 100
    # Check input, if numpy array, make dataframe
    if type(edges) is np.ndarray:
        edges = _npedges2dfedges(edges)
    # Set default behaviour of edgeweights
    if edgeweights is None or edgeweights is True:
        edgeweights = &#39;weight&#39;
    # Load the nifti node file
    if nodeimg is not None:
        nodes, nodeimg = _get_nodes_from_nii(
            nodeimg, voxsize=templatevoxsize, template=template, nodes=nodes)
    # Set nodecolor to colorby argument
    if nodecolorby is not None:
        nodecolor = _get_colorby_colors(nodes, nodecolorby, nodecmap)
    if highlightnodes is not None:
        nodecolor, highlightnodes = _highlight_nodes(nodes, nodecolor, nodealpha, highlightnodes, highlightlevel)
    ax_in = ax
    # Prespecify ouput ax list
    ax_out = []
    # Ax counter for double forloop
    axind = -1
    for ri in range(nrows):
        # Get the azim, elev and arrowaxis for each row
        azim, elev, arrowaxis_row = _get_view(
            view[ri], frames, arrowaxis=arrowaxis)
        for fi in range(frames):
            axind += 1
            # Get hemisphere for this frame
            hemi_frame = get_frame_input(hemisphere, axind, ri, fi)
            # Get title for this frame
            title_frame = get_frame_input(title, axind, ri, fi)
            # Set up subplot                
            if ax_in is None:
                subplotid = rows + colnum + axind + 1
                ax = fig.add_subplot(subplotid, projection=&#39;3d&#39;)
            elif isinstance(ax_in, list):
                # here ax can only be a 1d list, not 2d list.
                ax = ax_in[axind]
            else:
                ax = ax_in

            affine = None
            if template is not None:
                affine = _plot_template(ax, templatestyle, template, templatecolor=templatecolor,
                                        alpha=templatealpha, voxsize=templatevoxsize,
                                        surface_resolution=surface_resolution,
                                        edgethreshold=templateedgethreshold,
                                        azim=azim[fi], elev=elev[fi],
                                        hemisphere=hemi_frame)
            # Template voxels will have origin at 0,0,0
            # It is easier to scale the nodes from the image affine
            # Then to rescale the ax.voxels function
            # So if affine is not None, nodes get scaled in relation to origin and voxelsize,
            # If node coords are derived from nodeimg, this has already been taken care of.
            if nodes is not None and nodeimg is None and axind == 0:
                nodes = _scale_nodes(nodes, affine, nodecols)
            # nodes and subplot may change for each frame/subplot
            # e.g. if hemisphere is specified      
            nodes_frame = None     
            if nodes is not None:
                nodes_frame = nodes.copy()
                nodes_frame = _select_single_hemisphere_nodes(nodes_frame, affine, hemi_frame, nodecols)

                if nodetype == &#39;spheres&#39;:
                    _plot_spheres(ax, nodes_frame, nodecolor=nodecolor,
                                  nodesize=nodesize, nodecols=nodecols, nodescale=nodescale)
                elif nodetype == &#39;circles&#39;:
                    _plot_nodes(ax, nodes_frame, nodecolor=nodecolor,
                                nodesize=nodesize, nodecols=nodecols)
                elif nodetype == &#39;parcels&#39;:
                    _plot_parcels(ax, nodeimg, alpha=nodealpha,
                                  cmap=nodecolor, parcel_surface_resolution=surface_resolution,
                                  hemisphere=hemi_frame)
            if edges is not None:
                edges_frame = edges.copy()
                _plot_edges(ax, nodes_frame, edges_frame, edgewidth=edgeweights, edgewidthscale=edgescale,
                            edgecolor=edgecolor, edgealpha=edgealpha, highlightnodes=highlightnodes, highlightlevel=highlightlevel,
                            edgehighlightbehaviour=edgehighlightbehaviour)
            if arrowaxis_row is not None:
                _add_axis_arrows(ax, dims=arrowaxis_row,
                                 length=arrowlength, origin=arroworigin,
                                 azim=azim[fi], elev=elev[fi])

            ax.view_init(azim=azim[fi], elev=elev[fi])
            _add_subplot_title(ax, azim[fi], elev[fi], title_frame, hemi_frame)
            # Fix the aspect ratio
            ax.set_box_aspect([1, 1, 1])
            _set_axes_equal(ax)
            ax.axis(&#39;off&#39;)
            # Append ax to ax_out to store it.
            ax_out.append(ax)

    fig.tight_layout()
    return ax_out</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="netplotbrain.plot.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>nodes=None, fig=None, ax=None, view='L', frames=1, edges=None, template=None, templatestyle='filled', templatealpha=0.2, templatevoxsize=None, templatecolor='lightgray', surface_resolution=2, templateedgethreshold=0.7, arrowaxis='auto', arrowlength=10, arroworigin=None, edgecolor='k', nodesize=1, nodescale=5, nodecolor='salmon', nodetype='spheres', nodecolorby=None, nodecmap='Dark2', edgescale=1, edgeweights=True, nodecols=['x', 'y', 'z'], nodeimg=None, nodealpha=1, hemisphere='both', title='auto', highlightnodes=None, edgealpha=1, highlightlevel=0.85, edgehighlightbehaviour='both')</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a network on a brain</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib ax with 3D projection</code></dt>
<dd>fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
bnv.plot(ax, &hellip;)</dd>
<dt><strong><code>view</code></strong> :&ensp;<code>string, list,</code> or <code>tuple</code></dt>
<dd>if string: alternatives are 'A' (anterior), 'P' (posteiror), 'L' (left), 'R' (right), 'I' (inferior), 'S' (superior)
or any combination of these (e.g 'LR', 'AP')
The string can contain multiple combinations (e.g. LSR)
if list: multiple strings (as above) which will create new rows of subplots.
if tuple: (azim, elev) where azim rotates along xy, and elev rotates along xz.
If LR or AP view combinations only, you can specify i.e. 'AP-' to rotate in the oposite direction</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe, string</code></dt>
<dd>The dataframe must include x, y, z columns that correspond to coordinates of nodes (see nodecols to change this).
Can include additional infomation for node size and color.
If string, can load a tsv file (tab seperator), assumes index column is the 0th column.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>dataframe, numpy array,</code> or <code>string</code></dt>
<dd>If dataframe, must include i, j columns (and weight, for weighted).
i and j specify indicies in nodes.
See edgecols if you want to change the default column names.
if numpy array, square adjacecny array.
If string, can load a tsv file (tab seperator), assumes index column is the 0th column.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code>str</code> or <code>nibabel nifti</code></dt>
<dd>Path to nifti image, or templateflow template name (see templateflow.org) in order to automatically download T1 template.</dd>
<dt><strong><code>templatestyle</code></strong> :&ensp;<code>str</code></dt>
<dd>can be 'surface': (a surface is rendered from the template),
'filled': (a single transparant color)
'cloudy': cloudy (cloudy scatter edges outline the figure)</dd>
<dt><strong><code>surface_resolution</code></strong> :&ensp;<code>int</code></dt>
<dd>If templatestyle=='surface' controls the size of the triangles used in the surface reconstruction (default: 2).</dd>
<dt><strong><code>templatecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>If templatestyle=='surface' or 'filled', the color of template voxels</dd>
<dt><strong><code>templateedgedetection</code></strong> :&ensp;<code>float</code></dt>
<dd>If templatestyle=='cloudy', can tweak the edges detection threshold.</dd>
<dt><strong><code>templatealpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Opacity of template voxels.</dd>
<dt><strong><code>templatevoxelsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Resize voxels this size. Larger voxels = quicker. Default = 2</dd>
<dt><strong><code>arrowaxis</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>Adds axis arrows onto plot. Alternatives are: LR, AP, SI, 'all'</dd>
<dt><strong><code>arrowlength</code></strong> :&ensp;<code>int, float</code></dt>
<dd>Length of arrow</dd>
<dt><strong><code>arroworigin</code></strong> :&ensp;<code>list</code></dt>
<dd>x,y,z coordinates of arrowaxis. Note 0,0,0 is bottom left.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>matplotlib coloring</code></dt>
<dd>Can be string (default 'black') or list of 3D/4D colors for each edge.</dd>
<dt><strong><code>edgewidth</code></strong> :&ensp;<code>int, float</code></dt>
<dd>Specify width of edges. If auto, will plot the value in edge array (if array) or the weight column (if in pandas dataframe), otherwise 2.</dd>
<dt><strong><code>edgeweights</code></strong> :&ensp;<code>string</code></dt>
<dd>String that specifies column in edge dataframe that contains weights.
If numpy array is edge input, can be True (default) to specify edge weights.</dd>
<dt><strong><code>edgealpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Transparency of edges.</dd>
<dt><strong><code>nodesize</code></strong> :&ensp;<code>str, int, float</code></dt>
<dd>If string, can plot a column</dd>
<dt><strong><code>nodecolorby</code></strong> :&ensp;<code>str</code></dt>
<dd>Column in dataframe that should get different colors (cannot be set with nodecolor)</dd>
<dt><strong><code>nodecmap</code></strong> :&ensp;<code>str</code></dt>
<dd>Matplotlib colormap for node coloring with nodecolorby.</dd>
<dt><strong><code>nodecolor</code></strong> :&ensp;<code>matplotlib coloring</code></dt>
<dd>Can be string (default 'black') or list of 3D/4D colors for each edge.</dd>
<dt><strong><code>nodetype</code></strong> :&ensp;<code>str</code></dt>
<dd>Can be 'spheres', 'circles', or (if nodeimg is specified) 'parcels'.</dd>
<dt><strong><code>nodeimg</code></strong> :&ensp;<code>str</code> or <code>nii</code></dt>
<dd>String to filename or nibabel object that contains nodes as int.</dd>
<dt><strong><code>nodealpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Specify the transparency of the nodes</dd>
<dt><strong><code>frames</code></strong> :&ensp;<code>int</code></dt>
<dd>If specifying 2 views (e.g. LR or AP) and would like to rotates a between them.
This value will indicate the number of rotations to get from L to R.
For any other view specification, (e.g. specifying string such as 'LSR')
then this value is not needed.</dd>
<dt><strong><code>hemisphere</code></strong> :&ensp;<code>string</code> or <code>list</code></dt>
<dd>If string, can be left or right to specify single hemisphere to include.
If list, should match the size of views and contain strings to specify hemisphere.
Can be abbreviated to L, R and (empty string possible if both hemisphere plotted).<br>
Between hemispehre edges are deleted.</dd>
<dt><strong><code>nodecols</code></strong> :&ensp;<code>list</code></dt>
<dd>Node column names in node dataframe. Default is x, y, z (specifying coordinates)</dd>
<dt><strong><code>edgecols</code></strong> :&ensp;<code>list</code></dt>
<dd>Edge columns names in edge dataframe. Default is i and j (specifying nodes).</dd>
<dt><strong><code>highlightnodes</code></strong> :&ensp;<code>int, list, dict</code></dt>
<dd>List or int point out which nodes you want to be highlighted.
If dict, should be a single column-value pair.
Example: highlight all nodes of that, in the node dataframe, have a community
value of 1, the input will be {'community': 1}.</dd>
<dt><strong><code>highlightlevel</code></strong> :&ensp;<code>float</code></dt>
<dd>Intensity of the highlighting (opposite of alpha).
Value between 0 and 1, if 1, non-highlighted nodes are fully transparent.
If 0, non-highlighted nodes are same alpha level as highlighted nodes.
Default 0.85.</dd>
<dt><strong><code>edgehighlightbehaviour</code></strong> :&ensp;<code>str</code></dt>
<dd>Alternatives "both" or "any" or None.
Governs edge dimming when highlightnodes is on
If both, then highlights only edges between highlighted nodes.
If any, then only edges connecting any of the nodes are highlighted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(nodes=None, fig=None, ax=None, view=&#39;L&#39;, frames=1, edges=None, template=None, templatestyle=&#39;filled&#39;, templatealpha=0.2,
         templatevoxsize=None, templatecolor=&#39;lightgray&#39;, surface_resolution=2, templateedgethreshold=0.7, arrowaxis=&#39;auto&#39;, arrowlength=10,
         arroworigin=None, edgecolor=&#39;k&#39;, nodesize=1, nodescale=5, nodecolor=&#39;salmon&#39;, nodetype=&#39;spheres&#39;, nodecolorby=None,
         nodecmap=&#39;Dark2&#39;, edgescale=1, edgeweights=True, nodecols=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;], nodeimg=None, nodealpha=1, hemisphere=&#39;both&#39;, title=&#39;auto&#39;, highlightnodes=None,
         edgealpha=1, highlightlevel=0.85, edgehighlightbehaviour=&#39;both&#39;):
    # sourcery skip: merge-nested-ifs
    &#34;&#34;&#34;
    Plot a network on a brain

    Parameters
    ---------------------

    ax : matplotlib ax with 3D projection
        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        bnv.plot(ax, ...)
    view : string, list, or tuple
        if string: alternatives are &#39;A&#39; (anterior), &#39;P&#39; (posteiror), &#39;L&#39; (left), &#39;R&#39; (right), &#39;I&#39; (inferior), &#39;S&#39; (superior)
        or any combination of these (e.g &#39;LR&#39;, &#39;AP&#39;)
        The string can contain multiple combinations (e.g. LSR)
        if list: multiple strings (as above) which will create new rows of subplots.
        if tuple: (azim, elev) where azim rotates along xy, and elev rotates along xz.
        If LR or AP view combinations only, you can specify i.e. &#39;AP-&#39; to rotate in the oposite direction
    nodes : dataframe, string
        The dataframe must include x, y, z columns that correspond to coordinates of nodes (see nodecols to change this).
        Can include additional infomation for node size and color.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column. 
    edges : dataframe, numpy array, or string
        If dataframe, must include i, j columns (and weight, for weighted).
        i and j specify indicies in nodes.
        See edgecols if you want to change the default column names. 
        if numpy array, square adjacecny array.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column. 
    template : str or nibabel nifti
        Path to nifti image, or templateflow template name (see templateflow.org) in order to automatically download T1 template.
    templatestyle : str
        can be &#39;surface&#39;: (a surface is rendered from the template),
               &#39;filled&#39;: (a single transparant color)
               &#39;cloudy&#39;: cloudy (cloudy scatter edges outline the figure)
    surface_resolution : int
        If templatestyle==&#39;surface&#39; controls the size of the triangles used in the surface reconstruction (default: 2).
    templatecolor : str
        If templatestyle==&#39;surface&#39; or &#39;filled&#39;, the color of template voxels
    templateedgedetection : float
        If templatestyle==&#39;cloudy&#39;, can tweak the edges detection threshold.
    templatealpha : float
        Opacity of template voxels.
    templatevoxelsize : int
        Resize voxels this size. Larger voxels = quicker. Default = 2
    arrowaxis : list or str
        Adds axis arrows onto plot. Alternatives are: LR, AP, SI, &#39;all&#39;
    arrowlength : int, float
        Length of arrow
    arroworigin : list
        x,y,z coordinates of arrowaxis. Note 0,0,0 is bottom left.
    edgecolor : matplotlib coloring
        Can be string (default &#39;black&#39;) or list of 3D/4D colors for each edge.
    edgewidth : int, float
        Specify width of edges. If auto, will plot the value in edge array (if array) or the weight column (if in pandas dataframe), otherwise 2.
    edgeweights : string
        String that specifies column in edge dataframe that contains weights.
        If numpy array is edge input, can be True (default) to specify edge weights.
    edgealpha : float
        Transparency of edges.
    nodesize : str, int, float
        If string, can plot a column
    nodecolorby : str
        Column in dataframe that should get different colors (cannot be set with nodecolor)
    nodecmap : str
        Matplotlib colormap for node coloring with nodecolorby. 
    nodecolor : matplotlib coloring
        Can be string (default &#39;black&#39;) or list of 3D/4D colors for each edge.
    nodetype : str
        Can be &#39;spheres&#39;, &#39;circles&#39;, or (if nodeimg is specified) &#39;parcels&#39;.
    nodeimg : str or nii
        String to filename or nibabel object that contains nodes as int.
    nodealpha : float
        Specify the transparency of the nodes
    frames : int
        If specifying 2 views (e.g. LR or AP) and would like to rotates a between them.
        This value will indicate the number of rotations to get from L to R.
        For any other view specification, (e.g. specifying string such as &#39;LSR&#39;)
        then this value is not needed.
    hemisphere: string or list
        If string, can be left or right to specify single hemisphere to include.
        If list, should match the size of views and contain strings to specify hemisphere.
        Can be abbreviated to L, R and (empty string possible if both hemisphere plotted).  
        Between hemispehre edges are deleted.
    nodecols : list
        Node column names in node dataframe. Default is x, y, z (specifying coordinates)
    edgecols : list
        Edge columns names in edge dataframe. Default is i and j (specifying nodes).
    highlightnodes : int, list, dict
        List or int point out which nodes you want to be highlighted.
        If dict, should be a single column-value pair.
        Example: highlight all nodes of that, in the node dataframe, have a community
        value of 1, the input will be {&#39;community&#39;: 1}.   
    highlightlevel : float
        Intensity of the highlighting (opposite of alpha).
        Value between 0 and 1, if 1, non-highlighted nodes are fully transparent.
        If 0, non-highlighted nodes are same alpha level as highlighted nodes.
        Default 0.85. 
    edgehighlightbehaviour : str
        Alternatives &#34;both&#34; or &#34;any&#34; or None.
        Governs edge dimming when highlightnodes is on
        If both, then highlights only edges between highlighted nodes.
        If any, then only edges connecting any of the nodes are highlighted.


    &#34;&#34;&#34;
    # Load edge and nodes if string is provided. 
    if isinstance(nodes, str): 
        nodes = pd.read_csv(nodes, sep=&#39;\t&#39;, index_col=0)
    if isinstance(edges, str): 
        edges = pd.read_csv(edges, sep=&#39;\t&#39;, index_col=0)
    # get the number of views
    if isinstance(view, list):
        nrows = len(view)
    else:
        nrows = 1
        view = [view]
    # If specific views are given, calculate value of frames.
    if len(view[0]) &gt; 2:
        frames = len(view[0])
    n_subplots = nrows * frames
    if ax is not None and not isinstance(ax, list) and n_subplots &gt; 1:
        raise ValueError(
            &#39;Ax input must be a list when requesting multiple frames&#39;)
    if isinstance(ax, list):
        if len(ax) != n_subplots:
            raise ValueError(&#39;Ax list, must equal number of frames requested&#39;)
    # Init figure, if not given as input
    if ax is None:
        fig = plt.figure(figsize=(frames * 3, 3 * nrows))
        colnum = frames * 10
        rows = nrows * 100
    # Check input, if numpy array, make dataframe
    if type(edges) is np.ndarray:
        edges = _npedges2dfedges(edges)
    # Set default behaviour of edgeweights
    if edgeweights is None or edgeweights is True:
        edgeweights = &#39;weight&#39;
    # Load the nifti node file
    if nodeimg is not None:
        nodes, nodeimg = _get_nodes_from_nii(
            nodeimg, voxsize=templatevoxsize, template=template, nodes=nodes)
    # Set nodecolor to colorby argument
    if nodecolorby is not None:
        nodecolor = _get_colorby_colors(nodes, nodecolorby, nodecmap)
    if highlightnodes is not None:
        nodecolor, highlightnodes = _highlight_nodes(nodes, nodecolor, nodealpha, highlightnodes, highlightlevel)
    ax_in = ax
    # Prespecify ouput ax list
    ax_out = []
    # Ax counter for double forloop
    axind = -1
    for ri in range(nrows):
        # Get the azim, elev and arrowaxis for each row
        azim, elev, arrowaxis_row = _get_view(
            view[ri], frames, arrowaxis=arrowaxis)
        for fi in range(frames):
            axind += 1
            # Get hemisphere for this frame
            hemi_frame = get_frame_input(hemisphere, axind, ri, fi)
            # Get title for this frame
            title_frame = get_frame_input(title, axind, ri, fi)
            # Set up subplot                
            if ax_in is None:
                subplotid = rows + colnum + axind + 1
                ax = fig.add_subplot(subplotid, projection=&#39;3d&#39;)
            elif isinstance(ax_in, list):
                # here ax can only be a 1d list, not 2d list.
                ax = ax_in[axind]
            else:
                ax = ax_in

            affine = None
            if template is not None:
                affine = _plot_template(ax, templatestyle, template, templatecolor=templatecolor,
                                        alpha=templatealpha, voxsize=templatevoxsize,
                                        surface_resolution=surface_resolution,
                                        edgethreshold=templateedgethreshold,
                                        azim=azim[fi], elev=elev[fi],
                                        hemisphere=hemi_frame)
            # Template voxels will have origin at 0,0,0
            # It is easier to scale the nodes from the image affine
            # Then to rescale the ax.voxels function
            # So if affine is not None, nodes get scaled in relation to origin and voxelsize,
            # If node coords are derived from nodeimg, this has already been taken care of.
            if nodes is not None and nodeimg is None and axind == 0:
                nodes = _scale_nodes(nodes, affine, nodecols)
            # nodes and subplot may change for each frame/subplot
            # e.g. if hemisphere is specified      
            nodes_frame = None     
            if nodes is not None:
                nodes_frame = nodes.copy()
                nodes_frame = _select_single_hemisphere_nodes(nodes_frame, affine, hemi_frame, nodecols)

                if nodetype == &#39;spheres&#39;:
                    _plot_spheres(ax, nodes_frame, nodecolor=nodecolor,
                                  nodesize=nodesize, nodecols=nodecols, nodescale=nodescale)
                elif nodetype == &#39;circles&#39;:
                    _plot_nodes(ax, nodes_frame, nodecolor=nodecolor,
                                nodesize=nodesize, nodecols=nodecols)
                elif nodetype == &#39;parcels&#39;:
                    _plot_parcels(ax, nodeimg, alpha=nodealpha,
                                  cmap=nodecolor, parcel_surface_resolution=surface_resolution,
                                  hemisphere=hemi_frame)
            if edges is not None:
                edges_frame = edges.copy()
                _plot_edges(ax, nodes_frame, edges_frame, edgewidth=edgeweights, edgewidthscale=edgescale,
                            edgecolor=edgecolor, edgealpha=edgealpha, highlightnodes=highlightnodes, highlightlevel=highlightlevel,
                            edgehighlightbehaviour=edgehighlightbehaviour)
            if arrowaxis_row is not None:
                _add_axis_arrows(ax, dims=arrowaxis_row,
                                 length=arrowlength, origin=arroworigin,
                                 azim=azim[fi], elev=elev[fi])

            ax.view_init(azim=azim[fi], elev=elev[fi])
            _add_subplot_title(ax, azim[fi], elev[fi], title_frame, hemi_frame)
            # Fix the aspect ratio
            ax.set_box_aspect([1, 1, 1])
            _set_axes_equal(ax)
            ax.axis(&#39;off&#39;)
            # Append ax to ax_out to store it.
            ax_out.append(ax)

    fig.tight_layout()
    return ax_out</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netplotbrain" href="index.html">netplotbrain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="netplotbrain.plot.plot" href="#netplotbrain.plot.plot">plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>