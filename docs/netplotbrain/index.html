<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>netplotbrain API documentation</title>
<meta name="description" content="netplotbrain: visualizing networks in 3D on a brain â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>netplotbrain</code></h1>
</header>
<section id="section-intro">
<h1 id="netplotbrain-visualizing-networks-in-3d-on-a-brain">netplotbrain: visualizing networks in 3D on a brain</h1>
<p><a href="https://app.circleci.com/pipelines/github/wiheto/netplotbrain"><img alt="CircleCI" src="https://circleci.com/gh/wiheto/netplotbrain.svg?style=shield"></a>
<a href="https://www.codacy.com/gh/wiheto/netplotbrain/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=wiheto/netplotbrain&amp;utm_campaign=Badge_Grade"><img alt="Codacy Badge" src="https://app.codacy.com/project/badge/Grade/d2c620d4be8047989e7b91ac3bbbba97"></a>
<a href="https://zenodo.org/badge/latestdoi/317297000"><img alt="DOI" src="https://zenodo.org/badge/317297000.svg"></a>
<a href="https://coveralls.io/github/wiheto/netplotbrain?branch=main"><img alt="Coverage Status" src="https://coveralls.io/repos/github/wiheto/netplotbrain/badge.svg?branch=main"></a></p>
<p>Painlessly plot networks on a brain in python. The package is still in early development and better documentation/tutorials/examples are in the works.</p>
<p><img alt="" src="https://raw.githubusercontent.com/wiheto/netplotbrain/main/examples/figures/showcase.png"></p>
<h2 id="features">Features</h2>
<ol>
<li>Easy to specify properties: integration with pandas entails node and edge size/colour can easily be specified.</li>
<li>Flexibility: multiple node and template styles. Easily create multiple angles to view the figure.</li>
<li><a href="https://www.templateflow.org">TemplateFlow</a> integration to download any template or atlas.</li>
</ol>
<h2 id="installation">Installation</h2>
<p><code>pip install git+https://www.github.com/wiheto/netplotbrain</code></p>
<p>Note: We will release on pypi soon.</p>
<h2 id="how-it-works">How it works</h2>
<p>There are three components: (1) the nodes, (2) the edges, (3) the template</p>
<p>Each component functions independently.
You do not need to have all of them specified.</p>
<h2 id="nodes">Nodes</h2>
<p>There are two ways to specify nodes.</p>
<ol>
<li>
<p>Nodes: a pandas dataframe of coordinates</p>
</li>
<li>
<p>Nodeimg: a 3D nifti image where each node has a different value.
Alternatively, nodeimg can be dictionary to grab an atlas from templateflow.</p>
</li>
</ol>
<h3 id="nodes-dataframe">Nodes (Dataframe)</h3>
<p>The Pandas dataframe should have (at least) the columns 'x', 'y', and 'z'.
These columns should be coordinates in the space of the template (e.g. MNI).
It will look something like this.</p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">40</td>
<td align="center">50</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">-10</td>
<td align="center">40</td>
<td align="center">30</td>
</tr>
</tbody>
</table>
<p>Other columns can be used to style the node's colour and size.
These just become other columns in the dataframe.</p>
<table>
<thead>
<tr>
<th align="center">x</th>
<th align="center">y</th>
<th align="center">z</th>
<th align="center">communities</th>
<th align="center">degree_centrality</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">40</td>
<td align="center">50</td>
<td align="center">20</td>
<td align="center">1</td>
<td align="center">0.8</td>
</tr>
<tr>
<td align="center">-10</td>
<td align="center">40</td>
<td align="center">30</td>
<td align="center">1</td>
<td align="center">0.4</td>
</tr>
</tbody>
</table>
<p>With this information, you can easily specify colour and size arguments by specifying the column name:</p>
<p><code>netplotbrain.plot(..., nodecolor='communities')</code></p>
<p>These additional values to specify size and color can be given as a dataframe even
if you specify your nodes with a nifti image.</p>
<h3 id="nodeimg-nifti-image">Nodeimg (Nifti image)</h3>
<p>You can also input a 3D nifti image where each node is a unique value.</p>
<h3 id="nodeimg-templateflow-atlas">Nodeimg (Templateflow atlas)</h3>
<p>If you specify the key/value pairs of an atlas on templateflow in a dictionary,
the atlas will be automatically downloaded.
For example, the following will get the Schaefer2018 atlas.</p>
<pre><code class="language-python">nodeimg={'template': 'MNI152NLin2009cAsym',
         'atlas': 'Schaefer2018',
         'desc': '400Parcels7Networks',
         'resolution': 1}
</code></pre>
<p>See templateflow.org for more atlases.</p>
<p>If the template argument is specified in <code><a title="netplotbrain.plot" href="#netplotbrain.plot">plot()</a></code>,
then the template argument does not need to be included in the dictionary.</p>
<h2 id="edges-dataframe">Edges (dataframe)</h2>
<p>Edges as a numpy array (adj matrix) or as a pandas dataframe (edgelist) with the default columns 'i', 'j', and 'weight' (optional). An example:</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">j</th>
<th align="center">weight</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0.8</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0.5</td>
</tr>
</tbody>
</table>
<p><code>i</code> and <code>j</code> reference the indicies in . You can use the argument <code>edgecol</code> to specify different column names.</p>
<p>If numpy array, then the array should be a N x N array (where N is number of nodes).</p>
<h2 id="template-nifti-or-string">Template (nifti or string)</h2>
<p>For the template you can supply any nifti file.</p>
<p>You can also provide the template name for any template on templateflow.org.
The T1w brain mask will then automatically downloaded (if not already present on your computer) and used as the background.</p>
<p>Netplotbrain can render slightly different templates</p>
<h3 id="template-styles">Template Styles</h3>
<p>There are currently three background styles: "surface", "filled" and "cloudy".</p>
<p>The surface quickly renders a surface from the voxels. Additional arguments can be provided in order to the resolution of the surface.</p>
<p>The filled style plots the template's brain mask as voxels. This can be slightly RAM consuming.</p>
<p>The cloudy style tries to identify the outline of the mask and plots points along the edges. The cloudy style is quick, but the edge detection is run relative to the specified initial view of the plot.</p>
<p>For templates, you can change the voxelsize of the template. Larger voxels means the plot will be generated quicker.</p>
<h2 id="views">Views</h2>
<p>The view is the angle which the brain is viewed from in the plot.
You can specify it as a string:</p>
<ul>
<li>Left 'L',</li>
<li>Right 'R',</li>
<li>Anterior 'A',</li>
<li>Posterior 'P'</li>
<li>Superior 'S'</li>
<li>Inferior 'I'</li>
</ul>
<p>Sequences of views are possible.
So, setting view = 'LSR' will generate 3 subplots with left, superior, and right views</p>
<p>You can also specify the specific rotation (tuple): (xy-rotate, xz-rotate) in degrees. The R view is (0, 0)</p>
<h3 id="rotated-sequences-with-frames">Rotated sequences with frames</h3>
<p>You can also generate a sequence of rotated images.</p>
<p>If the view is two letters, (e.g. <code>'LR'</code>), then a sequence will be generated from the L-view to R-view.</p>
<p>The parameter <code>frames</code> will control how many images are generated.
Images will then be displayed along a single row.</p>
<p>If you specify a list (e.g. <code>['LR', 'AP']</code>) then two different rows will be generated.
The first from left to right. The second from anterior to posterior.</p>
<h2 id="minimal-examples">Minimal examples</h2>
<h3 id="import-necessary-packages-and-load-example-data">Import necessary packages and load example data</h3>
<pre><code class="language-python">
import netplotbrain
import pandas as pd
import matplotlib.pyplot as plt

# Example node and edges dataframes included with package
nodes = pd.read_csv('./examples/example_nodes.tsv', sep='\t', index_col=0)
edges = pd.read_csv('./examples/example_edges.tsv', sep='\t', index_col=0)

</code></pre>
<h3 id="plot-single-view">Plot single view</h3>
<pre><code class="language-python">netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  view='R',
                  nodes=nodes,
                  nodesize='centrality_measure1',
                  edges=edges)
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/singleview.png"></p>
<h3 id="specify-column-names-to-specify-size">Specify column names to specify size</h3>
<pre><code class="language-python">fig = plt.figure()
ax_m2 = fig.add_subplot(121, projection='3d')
netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  fig = fig,
                  ax = ax_m2,
                  view='A',
                  nodes=nodes,
                  nodesize='centrality_measure1',
                  nodecolor='red',
                  edges=edges)

ax_m2 = fig.add_subplot(122, projection='3d')
netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  fig = fig,
                  ax = ax_m2,
                  view='A',
                  nodes=nodes,
                  nodesize='centrality_measure2',
                  nodecolor='blue',
                  edges=edges)
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/measures.png"></p>
<h3 id="plot-multiple-rows">Plot multiple rows</h3>
<pre><code class="language-python">netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  nodes=nodes,
                  nodesize='centrality_measure1',
                  edges=edges,
                  view=['LSR', 'AIP'],
                  frames=2)
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/rows1.png"></p>
<h3 id="plot-atlas-as-nodes-from-templateflow">Plot atlas (as nodes) from templateflow</h3>
<pre><code class="language-python">netplotbrain.plot(nodeimg={'atlas': 'Schaefer2018',
                            'desc': '400Parcels7Networks',
                            'resolution': 1},
                  template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  view=['LSR'],
                  nodetype='circles')
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/atlas_circles.png"></p>
<h3 id="plot-atlas-as-parcels-from-templateflow">plot atlas (as parcels) from templateflow</h3>
<pre><code class="language-python">netplotbrain.plot(nodeimg={'atlas': 'Schaefer2018',
                            'desc': '400Parcels7Networks',
                            'resolution': 1},
                  template='MNI152NLin2009cAsym',
                  templatestyle=None,
                  view=['LSR'],
                  nodetype='parcels',
                  nodealpha=0.5,
                  nodecolor='Set3')
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/atlas_parcels.png"></p>
<h3 id="plot-individual-hemispheres">Plot individual hemispheres</h3>
<pre><code class="language-python">netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='surface',
                  view=['SSS'],
                  hemisphere=['L', 'R', ''],
                  nodes=nodesdf,
                  nodesize='centrality_measure1',
                  edges=edges)
</code></pre>
<p><img alt="" src="./examples/figures/hemi.png"></p>
<h3 id="plot-different-templates">Plot different templates</h3>
<pre><code class="language-python"># Generate data for WHS
xlim = [-6, 6]
ylim = [-10, 6]
zlim = [-3, 6]
nodes_whs, edges_whs = create_random_data(n, m, xlim, ylim, zlim)

# Setting templatevoxsize to 0.2 will make it slightly quicker
# Due to the voxel size being smaller, the nodes are currently smaller
# So scaling the nodes is useful.
netplotbrain.plot(template='WHS',
         templatestyle='surface',
         view='LSR',
         nodes=nodes_whs,
         nodesize='centrality_measure1',
         edges=edges_whs,
         nodescale=10,
         templatevoxsize=0.2)

plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/template_whs.png"></p>
<h3 id="plot-different-styles">Plot different styles</h3>
<pre><code class="language-python">netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='filled',
                  view='SPR',
                  nodes=nodes,
                  nodesize='centrality_measure1',
                  edges=edges)
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/styles1.png"></p>
<pre><code class="language-python">netplotbrain.plot(template='MNI152NLin2009cAsym',
                  templatestyle='cloudy',
                  view='SPR',
                  nodes=nodes,
                  nodesize='centrality_measure1',
                  edges=edges,
                  templatevoxsize=2)
plt.show()
</code></pre>
<p><img alt="" src="./examples/figures/styles2.png"></p>
<h2 id="get-involved">Get involved</h2>
<p>We hope to develop this package.
Please feel free to get in touch about what feature you want/would like to implement/would like to contribute to.</p>
<h2 id="citation">Citation</h2>
<p>If using netplotbrain in an academic article, please cite the package and the libraries it relies on.</p>
<p>Suggestion of text in methods section:</p>
<blockquote>
<h3 id="methods">Methods</h3>
<p>Network plots were generated using netplotbrain (Thompson &amp; Fanton 2021), which utilizes templateflow (Ciric et al 2021), matplotlib (Hunter 2007), pandas (McKinney 2011), numpy (Harris et al 2020), scipy (Virtanen et al 2020), nibabel (Brett et al 2020), and scikit-image (van der Walt et al 2014).</p>
<h3 id="references">References</h3>
<p>Brett, Matthew, Markiewicz, Christopher J., Hanke, Michael, CÃ´tÃ©, Marc-Alexandre, Cipollini, Ben, McCarthy, Paul, et al (2020, November 28). nipy/nibabel: 3.2.1 (Version 3.2.1). Zenodo. <a href="http://doi.org/10.5281/zenodo.4295521">http://doi.org/10.5281/zenodo.4295521</a></p>
<p>Ciric, R., Lorenz, R., Thompson, W. H., Goncalves, M., MacNicol, E., Markiewicz, C., &hellip; &amp; Esteban, O. (2021). TemplateFlow: a community archive of imaging templates and atlases for improved consistency in neuroimaging. bioRxiv.</p>
<p>Harris, C. R., Millman, K. J., van der Walt, S. J., Gommers, R., Virtanen, P., Cournapeau, D., &hellip; &amp; Oliphant, T. E. (2020). Array programming with NumPy. Nature, 585(7825), 357-362.</p>
<p>Hunter, J. D. (2007). Matplotlib: A 2D graphics environment. IEEE Annals of the History of Computing, 9(03), 90-95.</p>
<p>McKinney, W. (2011). pandas: a foundational Python library for data analysis and statistics. Python for High Performance and Scientific Computing, 14(9), 1-9.</p>
<p>Thompson WH, &amp; Fanton S. (2021, 10 March). wiheto/netplotbrain:. Zenodo. doi :10.5281/zenodo.4593837</p>
<p>Van der Walt, S., SchÃ¶nberger, J. L., Nunez-Iglesias, J., Boulogne, F., Warner, J. D., Yager, N., &hellip; &amp; Yu, T. (2014). scikit-image: image processing in Python. PeerJ, 2, e453.</p>
<p>Virtanen, P., Gommers, R., Oliphant, T. E., Haberland, M., Reddy, T., Cournapeau, D., &hellip; &amp; van Mulbregt, P. (2020). SciPy 1.0: fundamental algorithms for scientific computing in Python. Nature methods, 17(3), 261-272.</p>
</blockquote>
<h1 id="gallery">Gallery</h1>
<p>Click below on an image to find the code</p>
<p>(under construction)</p>
<h1 id="full-list-of-kwargs">Full list of KWARGS</h1>
<h2 id="node-kwargs">Node Kwargs</h2>
<p>nodecmap : str
Matplotlib colormap for node coloring with nodecolorby.
nodecolor : matplotlib coloring
Can be string (default 'black') or list of 3D/4D colors for each edge.
nodetype : str
Can be 'spheres', 'circles', or (if nodeimg is specified) 'parcels'.
nodealpha : float
Specify the transparency of the nodes
nodecols : list
Node column names in node dataframe. 'auto' entails the columsn are ['x', 'y', 'z'] (specifying coordinates)
nodevminvmax : str, list
Scaling alternatives if nodesize is given.
Alternatives: 'absolute' (default) 'minmax', or 2-tuple list of [min, max].
If minmax, node sizes are scaled between (0 and 1) * nodescale.
If absolute, then the default values are used.
Absolute can lead to problems with, for example, negative values.</p>
<pre><code>EDGE KWARGS

edgecols : list
    Edge columns names in edge dataframe. Default is i and j (specifying nodes).
edgecolor : matplotlib coloring
    Can be string (default 'black') or list of 3D/4D colors for each edge.
edgewidth : int, float
    Specify width of edges. If auto, will plot the value in edge array (if array) or the weight column (if in pandas dataframe), otherwise 2.
edgeweights : string
    String that specifies column in edge dataframe that contains weights.
    If numpy array is edge input, can be True (default) to specify edge weights.
edgealpha : float
    Transparency of edges (default: 1).
edgehighlightbehaviour : str
    Alternatives "both" or "any" or None.
    Governs edge dimming when highlightnodes is on
    If both, then highlights only edges between highlighted nodes.
    If any, then only edges connecting any of the nodes are highlighted.
edgewidthscale : int, float
    Scale the width of all edges by a factor (default: 1)

TEMPLATE KWARGS

templatecolor : str
    If templatestyle=='surface' or 'filled', the color of template voxels
templateedgethreshold : float
    If templatestyle=='cloudy', can tweak the edges detection threshold. (Default: 0.7)
templatealpha : float
    Opacity of template voxels.
templatevoxelsize : int
    Resize voxels this size. Larger voxels = quicker. (Default: 2)
surface_detection : float
    The value used to detect the surface boundrary (see argument level in marching_cubes).
    Some default choices are made for various templates
surface_resolution : int
    If templatestyle=='surface' controls the size of the triangles used in the surface reconstruction. (Default: 2).

LEGENDKWARGS

nodecolorlegend : True
    If the colorlegend is plotted or not.
nodesizelegend : True
nodecolorlegendstyle : str
    Alternatives: auto (default), discrete, continuious
    If the color legend should show the entire colormap or discrete colors.
    If auto, plots discrete if less than 8 unique values are detected.
legendtickfontsize : str, int
    Matplotlib fontsize for title in figure legends
legendtitlefontsize : str, int
    Matplotlib fontsize for ticks in figure legends

ARROW KWARGS

arrowaxis : list or str
    Adds axis arrows onto plot. Alternatives are: LR, AP, SI, 'all'
arrowlength : int, float
    Length of arrow
arroworigin : list
    x,y,z coordinates of arrowaxis. Note 0,0,0 is bottom left.

FIGURE KWARGS

ax : matplotlib ax with 3D projection
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    netplotbrain.plot(ax, ...)
fig : matplotlib figure


TEXT KWARGS

font : str
    font for all text in figure.
fontcolor : str, list, tuple
    font color for all text in figure
titlefontsize : str
    Size of title font (default: medium). See matplotlib "fontsize"
titleloc : str,
    Location of title (defualt: center). See matplotlib "loc"
titleweight : str
    Font weight of title (default: regular). See matplotlib "fontweight"

STYLE KWARGS

profile : str
    path or name of file in netplotbrain/profiles/&lt;filename&gt;.json, specifies default kwargs.
    Default points to netplotbrain/profiles/default.json
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../README.md

.. include:: ../docs/gallary.md
.. include:: ../docs/kwargs.rst
&#34;&#34;&#34;
from .plot import plot

__all__ = [&#39;plot&#39;]
__pdoc__ = {
    &#34;plotting&#34;: False,
    &#34;utils&#34;: False,
    &#34;templatesettings&#34;: False,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="netplotbrain.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>nodes=None, fig=None, ax=None, view='L', frames=1, edges=None, template=None, templatestyle='filled', templatevoxsize=None, arrowaxis='auto', arroworigin=None, edgecolor='k', nodesize=1, nodecolor='salmon', nodetype='circles', nodecolorby=None, nodecmap='Dark2', edgeweights=True, nodecols='auto', nodeimg=None, hemisphere='both', title='auto', highlightnodes=None, showlegend=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot a network on a brain</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>view</code></strong> :&ensp;<code>str, list,</code> or <code>tuple</code></dt>
<dd>If string: alternatives are 'A' (anterior), 'P' (posteiror), 'L' (left), 'R' (right), 'I' (inferior), 'S' (superior)
or any combination of these (e.g 'LR', 'AP')
The string can contain multiple combinations (e.g. LSR)
if list: multiple strings (as above) which will create new rows of subplots.
if tuple: (azim, elev) where azim rotates along xy, and elev rotates along xz.
If LR or AP view combinations only, you can specify i.e. 'AP-' to rotate in the oposite direction</dd>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dataframe, string</code></dt>
<dd>The dataframe must include x, y, z columns that correspond to coordinates of nodes (see nodecols to change this).
Can include additional infomation for node size and color.
If string, can load a tsv file (tab seperator), assumes index column is the 0th column.</dd>
<dt><strong><code>nodeimg</code></strong> :&ensp;<code>str</code> or <code>nii</code></dt>
<dd>String to filename or nibabel object that contains nodes as int.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>dataframe, numpy array,</code> or <code>string</code></dt>
<dd>If dataframe, must include i, j columns (and weight, for weighted).
i and j specify indicies in nodes.
See edgecols if you want to change the default column names.
if numpy array, square adjacecny array.
If string, can load a tsv file (tab seperator), assumes index column is the 0th column.</dd>
<dt><strong><code>template</code></strong> :&ensp;<code>str</code> or <code>nibabel nifti</code></dt>
<dd>Path to nifti image, or templateflow template name (see templateflow.org) in order to automatically download T1 template.</dd>
<dt><strong><code>templatestyle</code></strong> :&ensp;<code>str</code></dt>
<dd>can be 'surface': (a surface is rendered from the template),
'filled': (a single transparant color)
'cloudy': cloudy (cloudy scatter edges outline the figure)</dd>
<dt><strong><code>frames</code></strong> :&ensp;<code>int</code></dt>
<dd>If specifying 2 views (e.g. LR or AP) and would like to rotates a between them.
This value will indicate the number of rotations to get from L to R.
For any other view specification, (e.g. specifying string such as 'LSR')
then this value is not needed.</dd>
<dt><strong><code>hemisphere</code></strong> :&ensp;<code>string</code> or <code>list</code></dt>
<dd>If string, can be left or right to specify single hemisphere to include.
If list, should match the size of views and contain strings to specify hemisphere.
Can be abbreviated to L, R and (empty string possible if both hemisphere plotted).
Between hemispehre edges are deleted.</dd>
<dt><strong><code>highlightnodes</code></strong> :&ensp;<code>int, list, dict</code></dt>
<dd>List or int point out which nodes you want to be highlighted.
If dict, should be a single column-value pair.
Example: highlight all nodes of that, in the node dataframe, have a community
value of 1, the input will be {'community': 1}.</dd>
<dt><strong><code>highlightlevel</code></strong> :&ensp;<code>float</code></dt>
<dd>Intensity of the highlighting (opposite of alpha).
Value between 0 and 1, if 1, non-highlighted nodes are fully transparent.
If 0, non-highlighted nodes are same alpha level as highlighted nodes.
Default 0.85.</dd>
<dt><strong><code>showlegend</code></strong> :&ensp;<code>bool</code> or <code>list</code></dt>
<dd>If size or colour have been set, generates a legend for that property at bottom of figure.
If True, plots all the legends that can be plotted.
If list, can contain 'nodesize' and 'nodecolor' to plot those in the legend.
See legend kwargs for turning specific legends on/off.</dd>
<dt><strong><code>nodecolorby</code></strong> :&ensp;<code>str</code></dt>
<dd>Column in dataframe that should get different colors (cannot be set with nodecolor)</dd>
<dt><strong><code>nodesize</code></strong> :&ensp;<code>str, int, float</code></dt>
<dd>If string, can plot a column</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Default auto, will describe the view settings.
Otherwise string or list of for subplot titles</dd>
</dl>
<p>For more kew word arguments, see <code>netplotbrain.node-kwargs</code></p>
<h2 id="returns">Returns</h2>
<p>fig, ax - matplotlib figure and ax handles.
Legend handles should not be included but there should be an empty row in the figure size for each legend needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(nodes=None, fig=None, ax=None, view=&#39;L&#39;, frames=1, edges=None, template=None, templatestyle=&#39;filled&#39;,
         templatevoxsize=None, arrowaxis=&#39;auto&#39;, arroworigin=None, edgecolor=&#39;k&#39;, nodesize=1, nodecolor=&#39;salmon&#39;, nodetype=&#39;circles&#39;, nodecolorby=None,
         nodecmap=&#39;Dark2&#39;, edgeweights=True, nodecols=&#39;auto&#39;, nodeimg=None, hemisphere=&#39;both&#39;, title=&#39;auto&#39;, highlightnodes=None, showlegend=True, **kwargs):
    &#34;&#34;&#34;
    Plot a network on a brain

    Parameters
    ---------------------
    view : str, list, or tuple
        If string: alternatives are &#39;A&#39; (anterior), &#39;P&#39; (posteiror), &#39;L&#39; (left), &#39;R&#39; (right), &#39;I&#39; (inferior), &#39;S&#39; (superior)
        or any combination of these (e.g &#39;LR&#39;, &#39;AP&#39;)
        The string can contain multiple combinations (e.g. LSR)
        if list: multiple strings (as above) which will create new rows of subplots.
        if tuple: (azim, elev) where azim rotates along xy, and elev rotates along xz.
        If LR or AP view combinations only, you can specify i.e. &#39;AP-&#39; to rotate in the oposite direction
    
    nodes : dataframe, string
        The dataframe must include x, y, z columns that correspond to coordinates of nodes (see nodecols to change this).
        Can include additional infomation for node size and color.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column.
    
    nodeimg : str or nii
        String to filename or nibabel object that contains nodes as int.
    edges : dataframe, numpy array, or string
        If dataframe, must include i, j columns (and weight, for weighted).
        i and j specify indicies in nodes.
        See edgecols if you want to change the default column names.
        if numpy array, square adjacecny array.
        If string, can load a tsv file (tab seperator), assumes index column is the 0th column.
    template : str or nibabel nifti
        Path to nifti image, or templateflow template name (see templateflow.org) in order to automatically download T1 template.
    templatestyle : str
        can be &#39;surface&#39;: (a surface is rendered from the template),
               &#39;filled&#39;: (a single transparant color)
               &#39;cloudy&#39;: cloudy (cloudy scatter edges outline the figure)
    frames : int
        If specifying 2 views (e.g. LR or AP) and would like to rotates a between them.
        This value will indicate the number of rotations to get from L to R.
        For any other view specification, (e.g. specifying string such as &#39;LSR&#39;)
        then this value is not needed.
    hemisphere: string or list
        If string, can be left or right to specify single hemisphere to include.
        If list, should match the size of views and contain strings to specify hemisphere.
        Can be abbreviated to L, R and (empty string possible if both hemisphere plotted).
        Between hemispehre edges are deleted.
    highlightnodes : int, list, dict
        List or int point out which nodes you want to be highlighted.
        If dict, should be a single column-value pair.
        Example: highlight all nodes of that, in the node dataframe, have a community
        value of 1, the input will be {&#39;community&#39;: 1}.
    highlightlevel : float
        Intensity of the highlighting (opposite of alpha).
        Value between 0 and 1, if 1, non-highlighted nodes are fully transparent.
        If 0, non-highlighted nodes are same alpha level as highlighted nodes.
        Default 0.85.
    showlegend : bool or list
        If size or colour have been set, generates a legend for that property at bottom of figure.
        If True, plots all the legends that can be plotted.
        If list, can contain &#39;nodesize&#39; and &#39;nodecolor&#39; to plot those in the legend.
        See legend kwargs for turning specific legends on/off.
    nodecolorby : str
        Column in dataframe that should get different colors (cannot be set with nodecolor)
    nodesize : str, int, float
        If string, can plot a column
    title : str or list
        Default auto, will describe the view settings.
        Otherwise string or list of for subplot titles

    For more kew word arguments, see `netplotbrain.node-kwargs`

    Returns
    --------
    fig, ax - matplotlib figure and ax handles.
        Legend handles should not be included but there should be an empty row in the figure size for each legend needed.

    &#34;&#34;&#34;
    # Load default settings, then update with kwargs
    profile = _load_profile(**kwargs)

    # Check and load the input of nodes and edges
    nodes, nodeimg, nodecols = _process_node_input(
        nodes, nodeimg, nodecols, template, templatevoxsize)
    edges, edgeweights = _process_edge_input(edges, edgeweights)

    # Set up legend row
    # TODO compact code into subfunction
    legends = None
    legendrows = 0
    if isinstance(showlegend, list):
        legends = showlegend
        legendrows = len(legends)
    elif showlegend is True:
        # Only plot size legend is sphere/circle and string or list input
        # TODO setup_legend is a little clunky and could be fized
        if nodetype != &#39;parcel&#39; and not isinstance(nodesize, (float, int)):
            nodesizelegend = profile[&#39;nodesizelegend&#39;]
            legends = _setup_legend(
                nodesize, nodesizelegend, &#39;nodesize&#39;, legends)
        # Only plot color legend if colorby
        if nodecolorby is not None:
            nodecolorlegend = profile[&#39;nodecolorlegend&#39;]
            legends = _setup_legend(
                nodecolorby, nodecolorlegend, &#39;nodecolor&#39;, legends)
        if legends is not None:
            legendrows = len(legends)

    # Figure setup
    # Get number of non-legend rows
    nrows, view, frames = _nrows_in_fig(view, frames)
    # Init figure, if not given as input
    if ax is None:
        fig, gridspec = _init_figure(frames, nrows, legendrows)
    else:
        expected_ax_len = (nrows * frames)
        ax, gridspec = _check_axinput(ax, expected_ax_len)

    # Set nodecolor to colorby argument
    if nodecolorby is not None:
        nodecolor = _get_colorby_colors(nodes, nodecolorby, nodecmap)
    if highlightnodes is not None:
        nodecolor, highlightnodes = _highlight_nodes(
            nodes, nodecolor, highlightnodes, **profile)

    # Rename ax as ax_in and prespecfiy ax_out before forloop
    ax_in = ax
    ax_out = []
    # TODO remove double forloop and make single forloop by running over nrows and frames
    for ri in range(nrows):
        # Get the azim, elev and arrowaxis for each row
        azim, elev, arrowaxis_row = _get_view(
            view[ri], frames, arrowaxis=arrowaxis)
        for fi in range(frames):
            axind = (ri * nrows) + fi
            # Get hemisphere for this frame
            hemi_frame = get_frame_input(hemisphere, axind, ri, fi)
            # Get title for this frame
            title_frame = get_frame_input(title, axind, ri, fi)
            # Set up subplot
            if ax_in is None:
                ax = fig.add_subplot(gridspec[ri, fi], projection=&#39;3d&#39;)
            elif isinstance(ax_in, list):
                # here ax can only be a 1d list, not 2d list.
                ax = ax_in[axind]
            else:
                ax = ax_in
            affine = None
            if template is not None:
                affine = _plot_template(ax, templatestyle, template,
                                        voxsize=templatevoxsize,
                                        azim=azim[fi], elev=elev[fi],
                                        hemisphere=hemi_frame,
                                        **profile)
            # Template voxels will have origin at 0,0,0
            # It is easier to scale the nodes from the image affine
            # Then to rescale the ax.voxels function
            # So if affine is not None, nodes get scaled in relation to origin and voxelsize,
            # If node coords are derived from nodeimg, this has already been taken care of.
            if nodes is not None and nodeimg is None and axind == 0:
                nodes = _scale_nodes(nodes, nodecols, affine)
            # nodes and subplot may change for each frame/subplot
            # e.g. if hemisphere is specified
            nodes_frame = None
            if nodes is not None:
                nodes_frame = nodes.copy()
                nodes_frame = _select_single_hemisphere_nodes(
                    nodes_frame, nodecols[0], affine, hemi_frame)

                if nodetype == &#39;spheres&#39;:
                    _plot_spheres(ax, nodes_frame, nodecolor=nodecolor,
                                  nodesize=nodesize, nodecols=nodecols, **profile)
                elif nodetype == &#39;circles&#39;:
                    _plot_nodes(ax, nodes_frame, nodecolor=nodecolor,
                                nodesize=nodesize, nodecols=nodecols, **profile)
                elif nodetype == &#39;parcels&#39;:
                    _plot_parcels(ax, nodeimg, cmap=nodecolor,
                                  hemisphere=hemi_frame, **profile)
            if edges is not None:
                edges_frame = edges.copy()
                _plot_edges(ax, nodes_frame, edges_frame, edgewidth=edgeweights,
                            edgecolor=edgecolor, highlightnodes=highlightnodes, **profile)
            if arrowaxis_row is not None:
                _add_axis_arrows(ax, dims=arrowaxis_row,
                                 origin=arroworigin,
                                 azim=azim[fi], elev=elev[fi], **profile)

            ax.view_init(azim=azim[fi], elev=elev[fi])
            _add_subplot_title(ax, azim[fi], elev[fi], title_frame, hemi_frame, **profile)
            # Fix the aspect ratio
            ax.set_box_aspect([1, 1, 1])
            _set_axes_equal(ax)
            ax.axis(&#39;off&#39;)
            # Append ax to ax_out to store it.
            ax_out.append(ax)

    # Add legends to plot
    if legends is not None:
        for li, legend in enumerate(legends):
            print(legend)
            # setup legend subplot. Goes in centre or centre2 subplots
            spind = gridspec.ncols
            if np.remainder(spind, 2) == 0:
                legend_subplotp_colind = [int((spind / 2) - 1), int(spind / 2)]
            else:
                legend_subplotp_colind = int(np.round(spind / 2) - 1)
            ax = fig.add_subplot(gridspec[nrows + li, legend_subplotp_colind])
            if legend == &#39;nodesize&#39;:
                ax = _add_nodesize_legend(ax, nodes, nodesize, **profile)
            if legend == &#39;nodecolor&#39;:
                ax = _add_nodecolor_legend(
                    ax, nodes, nodecolorby, nodecolor, nodecmap, **profile)
            ax.axis(&#39;off&#39;)
            #ax = _add_size_legend(ax, nodes, nodesize, nodescale)
            ax_out.append(ax)
    fig.tight_layout()

    return (fig, ax_out)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#netplotbrain-visualizing-networks-in-3d-on-a-brain">netplotbrain: visualizing networks in 3D on a brain</a><ul>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#nodes">Nodes</a><ul>
<li><a href="#nodes-dataframe">Nodes (Dataframe)</a></li>
<li><a href="#nodeimg-nifti-image">Nodeimg (Nifti image)</a></li>
<li><a href="#nodeimg-templateflow-atlas">Nodeimg (Templateflow atlas)</a></li>
</ul>
</li>
<li><a href="#edges-dataframe">Edges (dataframe)</a></li>
<li><a href="#template-nifti-or-string">Template (nifti or string)</a><ul>
<li><a href="#template-styles">Template Styles</a></li>
</ul>
</li>
<li><a href="#views">Views</a><ul>
<li><a href="#rotated-sequences-with-frames">Rotated sequences with frames</a></li>
</ul>
</li>
<li><a href="#minimal-examples">Minimal examples</a><ul>
<li><a href="#import-necessary-packages-and-load-example-data">Import necessary packages and load example data</a></li>
<li><a href="#plot-single-view">Plot single view</a></li>
<li><a href="#specify-column-names-to-specify-size">Specify column names to specify size</a></li>
<li><a href="#plot-multiple-rows">Plot multiple rows</a></li>
<li><a href="#plot-atlas-as-nodes-from-templateflow">Plot atlas (as nodes) from templateflow</a></li>
<li><a href="#plot-atlas-as-parcels-from-templateflow">plot atlas (as parcels) from templateflow</a></li>
<li><a href="#plot-individual-hemispheres">Plot individual hemispheres</a></li>
<li><a href="#plot-different-templates">Plot different templates</a></li>
<li><a href="#plot-different-styles">Plot different styles</a></li>
</ul>
</li>
<li><a href="#get-involved">Get involved</a></li>
<li><a href="#citation">Citation</a><ul>
<li><a href="#methods">Methods</a></li>
<li><a href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#gallery">Gallery</a></li>
<li><a href="#full-list-of-kwargs">Full list of KWARGS</a><ul>
<li><a href="#node-kwargs">NODE KWARGS</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="netplotbrain.plot" href="#netplotbrain.plot">plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>